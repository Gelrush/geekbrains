#include <iostream>

void doSomething() // УТЕЧКА ПАМЯТИ
{
    int* ptr = new int; // если не освобождать выделенную память до выхода из осбалти видимости переменной указателя
            // то память уже невозможно будет освободить после. Такое называется "утечкой памяти".
    int value = 7;
    int* ptr1 = new int; // выделяем память
    ptr1 = &value; // старый адрес утерян - произойдет "утечка памяти"

    int* ptr2 = new int;
    ptr2 = new int; // старый адрес утерян - произойдет "утечка памяти"

    delete ptr; // поэтому необходимо каждый раз освобождать память
}

int main()
{   
    int* ptr = new int; // динамически выделяем целочисленную переменную и присваиваем её адрес ptr, чтобы затем иметь доступ к ней
                        // память выделяется из "кучи"
    *ptr = 8; // присваиваем значение 8 только что выделенной памяти

    int* ptr1 = new int(7); // используем прямую инициализацию
    int* ptr2 = new int{ 8 }; // используем uniform-инициализацию
    {
        delete ptr; // возвращаем память, на которую указывал ptr, обратно в операционную систему
            // Указатель, указывающий на освобожденную память, называется висячим указателем.
        ptr = nullptr; // делаем ptr нулевым указателем (используйте nullptr вместо '0' в C++11)
    }
    {
        delete ptr1; // возвращаем память обратно в операционную систему, ptr теперь является висячим указателем
        std::cout << *ptr1; // разыменование висячего указателя приведет к неожиданным результатам
        delete ptr1; // попытка освободить память снова приведет к неожиданным результатам также
    }
    {
        int* otherPtr = ptr2; // otherPtr теперь указывает на ту же самую выделенную память, что и ptr

        delete ptr2; // возвращаем память обратно в операционную систему. ptr и otherPtr теперь висячие указатели
        ptr2 = 0; // ptr теперь уже nullptr

        // Однако, otherPtr по-прежнему является висячим указателем!
    }
    {
        // если память не выделилась (закончилась), то генерируется исключение bad_alloc. Решение:
        int* value = new (std::nothrow) int; // указатель value станет нулевым, если динамическое выделение целочисленной переменной не выполнится
        if (!value) // обрабатываем случай, когда new возвращает null (т.е. память не выделяется)
        {
            // Обработка этого случая
            std::cout << "Could not allocate memory";
        }
        delete value; // Если значением указателя является нуль, то ничего не произойдет
    }
    return 0;
}
