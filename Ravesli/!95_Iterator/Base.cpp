#include <iostream>
#include <array>
#include <iterator> // для std::begin() и std::end()
#include <vector>

            /* Итерация по элементам структур данных */


// typedef unsigned int size_t
int main() 
{   
    {
        // Автоматическое определение типа как std::array<int, 7> (требуется поддержка стандарта C++17)
        std::array data{ 0, 1, 2, 3, 4, 5, 6 };  // используйте std::array<int, 7>, если ваш компилятор не поддерживает C++17
        const std::size_t length{ std::size(data) }; // инициализация длины массива
        {
            // Цикл while с использованием явного индекса
            std::size_t index{ 0 };
            while (index != length)
            {
                std::cout << data[index] << ' ';
                ++index;
            }
            std::cout << '\n';
        }
        {
            // Цикл for с использованием явного индекса
            for (size_t index = 0; index < length; ++index)
                std::cout << data[index] << ' ';
            std::cout << '\n';
        }
        {
            // Цикл for с использованием указателей (обратите внимание, ptr не может быть const, так как позже мы выполняем с ним операцию инкремента)
            for (auto ptr{ &data[0] }; ptr != (&data[0] + length); ++ptr) // Обратите внимание, что здесь мы указываем на место, следующее за последним элементом
                std::cout << *ptr << ' '; // арифметика указателей допустима если элементы расположены друг за другом
            std::cout << '\n';
        }
        {
            // Цикл for с явным указанием диапазона
            for (int i : data) // незаметно обращаются к вызовам функций begin() и end()
                std::cout << i << ' ';
            std::cout << '\n';
        }
        {
            // Просим наш массив указать нам начальную и конечную точки при помощи функций begin() и end()
            auto begin{ data.begin() }; // class std::_Array_iterator<int,7>
            auto end{ data.end() }; 
            
;            for (auto p{ begin }; p != end; ++p) // выполняем инкремент для перехода к следующему элементу
            {
                std::cout << *p << ' '; // разыменовываем указатель для получения текущего значения элемента
            }
            std::cout << '\n';
        }
        {
            auto begin{ std::begin(data) }; // #include <iterator>
            auto end{ std::end(data) };     // #include <iterator>
            
            for (auto p{ begin }; p != end; ++p) // выполняем инкремент для перехода к следующему элементу
            {
                std::cout << *p << ' '; // разыменовываем указатель для получения текущего значения элемента 
            }
            std::cout << '\n';
        } /* C динамическими массивами данные способы не работает, так как для них не существует функции std::end() (из-за того, что отсутствует информация о длине массива)*/
        

        { // «инвалидации итераторов» в std::vector
            std::vector v{ 1, 2, 3, 4, 5, 6, 7 };
            int* arr = new int[5]{ 5, 1, 2, 3, 4 };

            auto it{ v.begin() };

            //++it; // двигаемся ко второму элементу
            std::cout << *it << '\n'; // ок: выводится "2"

            v.erase(it); // удаляем элемент, на который в данный момент указывает итератор

            // erase() инвалидирует итераторы для стираемого элемента (и последующих элементов тоже),
            // поэтому теперь итератор "it" является недействительным

            ++it; // неопределенное поведение
            std::cout << *it << '\n'; // неопределенное поведение
        }
    }


    return 0;
}
