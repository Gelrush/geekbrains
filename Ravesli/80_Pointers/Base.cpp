#include <iostream>

int main()
{   
    int a = 7;
    std::cout << a << '\n'; // выводим значение переменной a
    std::cout << &a << '\n'; // выводим адрес памяти переменной a
    std::cout << *&a << '\n'; /// выводим значение ячейки памяти переменной a 
                // (Оператор разыменования * позволяет получить значение по указанному адресу)

    int *iPtr1; // указатель на значение типа int
    int *iPtr5, *iPtr6; // объявляем два указателя для переменных типа int
    int *iPtr3, iPtr4; // iPtr3 - это указатель на значение типа int, а iPtr4 - это обычная переменная типа int!

    int value = 5;
    int *ptr = &value; // инициализируем ptr адресом значения переменной

    std::cout << &value << '\n'; // выводим адрес значения переменной value
    std::cout << value << '\n'; // выводим содержимое value
    std::cout << ptr << '\n'; // выводим адрес, который хранит ptr
    std::cout << *ptr << '\n'; // выводит значение переменной по адресу (разыменование)
    std::cout << &ptr << '\n'; // выводит адрес указателя, который содержит адрес value

    *ptr = 7; // *ptr - это то же самое, что и value, которому мы присвоили значение 7
    std::cout << value << '\n'; // выведется 7

    {
        int iValue = 7;
        double dValue = 9.0;

        int* iPtr = &iValue; // ок
        double* dPtr = &dValue; // ок
        iPtr = &dValue; // неправильно: указатель типа int не может указывать на адрес переменной типа double
        dPtr = &iValue; // неправильно: указатель типа double не может указывать на адрес переменной типа int
        int* ptr = 7; // не является допустимым
        double* dPtr2 = 0x0012FF7C; // не ок: рассматривается как присваивание целочисленного литерала

        // Оператор адреса & не возвращает адрес своего операнда в качестве литерала, а возвращает указатель
    }
    
    {
        char* chPtr; // тип char занимает 1 байт
        int* iPtr; // тип int занимает 4 байта

        struct Something
        {
            int nX, nY, nZ;
        };

        Something* somethingPtr;

        std::cout << sizeof(chPtr) << '\n'; // выведется 4 для x86 и 8 для x64
        std::cout << sizeof(iPtr) << '\n'; // выведется 4 для x86 и 8 для x64
        std::cout << sizeof(somethingPtr) << '\n'; // выведется 4 для x86 и 8 для x64
    }
    {
    	struct Man
		{
    		int weight;
    		double height;
		};
		Man man;

    	// Доступ к члену осуществляется через использование фактической переменной структуры Man
    	man.weight = 60;
    	// Доступ к члену осуществляется через ссылку на переменную структуры Man
    	Man& ref = man;
    	ref.weight = 60;
    	// Доступ к члену осуществляется через указатель на переменную структуры Man
    	Man* ptr = &man;
    	(*ptr).weight = 60; // идентичны
    	ptr->weight = 60; // идентичны

    }

    return 0;
}
